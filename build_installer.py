#!/usr/bin/env python3
"""
Talinda POS Installer Builder
=============================

This script builds a standalone executable and creates an installer for the Talinda POS system.
"""

import os
import sys
import shutil
import subprocess
import platform
from pathlib import Path
import argparse

class InstallerBuilder:
    """Builds the Talinda POS installer."""
    
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.src_dir = self.project_root / "src"
        self.dist_dir = self.project_root / "dist"
        self.build_dir = self.project_root / "build"
        self.installer_dir = self.project_root / "installer"
        
        # Application info
        self.app_name = "Talinda POS"
        self.app_version = "2.0.0"
        self.app_author = "Talinda POS Team"
        self.app_description = "A comprehensive Point of Sale system built with PyQt5"
        
    def clean_build_directories(self):
        """Clean previous build artifacts."""
        print("Cleaning build directories...")
        
        if self.dist_dir.exists():
            shutil.rmtree(self.dist_dir)
        if self.build_dir.exists():
            shutil.rmtree(self.build_dir)
        if self.installer_dir.exists():
            shutil.rmtree(self.installer_dir)
            
        # Create directories
        self.dist_dir.mkdir(exist_ok=True)
        self.build_dir.mkdir(exist_ok=True)
        self.installer_dir.mkdir(exist_ok=True)
        
    def install_dependencies(self):
        """Install required dependencies for building."""
        print("Installing build dependencies...")
        
        build_deps = [
            "pyinstaller>=5.13.0",
            "pyinstaller-hooks-contrib>=2023.8",
        ]
        
        for dep in build_deps:
            try:
                subprocess.run([sys.executable, "-m", "pip", "install", dep], check=True)
                print(f"✓ Installed {dep}")
            except subprocess.CalledProcessError as e:
                print(f"✗ Failed to install {dep}: {e}")
                return False
                
        return True
        
    def create_pyinstaller_spec(self):
        """Create PyInstaller spec file."""
        spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['src/main.py'],
    pathex=[],
    binaries=[],
    datas=[
        ('src/resources', 'resources'),
        ('src/config.py', '.'),
        ('src/init_database.py', '.'),
        ('src/manage.py', '.'),
        ('src/fix_database.py', '.'),
        ('src/migrate_*.py', '.'),
    ],
    hiddenimports=[
        'PyQt5.QtCore',
        'PyQt5.QtGui', 
        'PyQt5.QtWidgets',
        'sqlalchemy',
        'sqlalchemy.orm',
        'sqlalchemy.ext.declarative',
        'bcrypt',
        'dotenv',
        'reportlab',
        'qrcode',
        'PIL',
        'openpyxl',
        'pytest',
        'pytest_qt',
        'pytest_cov',
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='{self.app_name.replace(" ", "_")}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='src/resources/images/logo.ico' if Path('src/resources/images/logo.ico').exists() else None,
)
'''
        
        spec_file = self.project_root / "talinda_pos.spec"
        with open(spec_file, 'w', encoding='utf-8') as f:
            f.write(spec_content)
            
        print(f"✓ Created PyInstaller spec file: {spec_file}")
        return spec_file
        
    def build_executable(self):
        """Build the standalone executable using PyInstaller."""
        print("Building executable with PyInstaller...")
        
        spec_file = self.create_pyinstaller_spec()
        
        try:
            cmd = [
                sys.executable, "-m", "PyInstaller",
                "--clean",
                "--noconfirm",
                str(spec_file)
            ]
            
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            print("✓ PyInstaller build completed successfully")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"✗ PyInstaller build failed: {e}")
            print(f"Error output: {e.stderr}")
            return False
            
    def create_nsis_installer_script(self):
        """Create NSIS installer script."""
        nsis_script = f'''# NSIS Installer Script for {self.app_name}
# Generated by InstallerBuilder

!define APP_NAME "{self.app_name}"
!define APP_VERSION "{self.app_version}"
!define APP_PUBLISHER "{self.app_author}"
!define APP_DESCRIPTION "{self.app_description}"
!define APP_EXE "{self.app_name.replace(" ", "_")}.exe"

# Include modern UI
!include "MUI2.nsh"

# General
Name "${{APP_NAME}}"
OutFile "{self.app_name.replace(" ", "_")}_Setup_v{self.app_version}.exe"
InstallDir "$PROGRAMFILES\\${{APP_NAME}}"
InstallDirRegKey HKCU "Software\\${{APP_NAME}}" ""

# Request application privileges
RequestExecutionLevel admin

# Interface Settings
!define MUI_ABORTWARNING
!define MUI_ICON "src\\resources\\images\\logo.ico"
!define MUI_UNICON "src\\resources\\images\\logo.ico"

# Pages
!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_LICENSE "LICENSE"
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_UNPAGE_CONFIRM
!insertmacro MUI_UNPAGE_INSTFILES

# Languages
!insertmacro MUI_LANGUAGE "English"
!insertmacro MUI_LANGUAGE "Arabic"

# Installer Sections
Section "Main Application" SecMain
    SetOutPath "$INSTDIR"
    
    # Copy executable and files
    File /r "dist\\{self.app_name.replace(" ", "_")}\\*.*"
    
    # Create uninstaller
    WriteUninstaller "$INSTDIR\\Uninstall.exe"
    
    # Create start menu shortcut
    CreateDirectory "$SMPROGRAMS\\${{APP_NAME}}"
    CreateShortCut "$SMPROGRAMS\\${{APP_NAME}}\\${{APP_NAME}}.lnk" "$INSTDIR\\${{APP_EXE}}"
    CreateShortCut "$SMPROGRAMS\\${{APP_NAME}}\\Uninstall.lnk" "$INSTDIR\\Uninstall.exe"
    
    # Create desktop shortcut
    CreateShortCut "$DESKTOP\\${{APP_NAME}}.lnk" "$INSTDIR\\${{APP_EXE}}"
    
    # Registry information for add/remove programs
    WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "DisplayName" "${{APP_NAME}}"
    WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "UninstallString" "$INSTDIR\\Uninstall.exe"
    WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "DisplayIcon" "$INSTDIR\\${{APP_EXE}}"
    WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "Publisher" "${{APP_PUBLISHER}}"
    WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "DisplayVersion" "${{APP_VERSION}}"
    WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "Description" "${{APP_DESCRIPTION}}"
    WriteRegDWORD HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "NoModify" 1
    WriteRegDWORD HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}" "NoRepair" 1
    
    # Registry information for application
    WriteRegStr HKCU "Software\\${{APP_NAME}}" "" $INSTDIR
SectionEnd

# Uninstaller Section
Section "Uninstall"
    # Remove start menu shortcuts
    Delete "$SMPROGRAMS\\${{APP_NAME}}\\${{APP_NAME}}.lnk"
    Delete "$SMPROGRAMS\\${{APP_NAME}}\\Uninstall.lnk"
    RMDir "$SMPROGRAMS\\${{APP_NAME}}"
    
    # Remove desktop shortcut
    Delete "$DESKTOP\\${{APP_NAME}}.lnk"
    
    # Remove files and uninstaller
    RMDir /r "$INSTDIR"
    
    # Remove registry keys
    DeleteRegKey HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${{APP_NAME}}"
    DeleteRegKey HKCU "Software\\${{APP_NAME}}"
SectionEnd
'''
        
        nsis_file = self.installer_dir / "installer.nsi"
        with open(nsis_file, 'w', encoding='utf-8') as f:
            f.write(nsis_script)
            
        print(f"✓ Created NSIS installer script: {nsis_file}")
        return nsis_file
        
    def create_installer(self):
        """Create the installer using NSIS."""
        print("Creating installer with NSIS...")
        
        nsis_script = self.create_nsis_installer_script()
        
        # Check if NSIS is available
        try:
            result = subprocess.run(["makensis", "/VERSION"], capture_output=True, text=True)
            if result.returncode == 0:
                print("✓ NSIS found")
            else:
                print("✗ NSIS not found. Please install NSIS to create installer.")
                print("Download from: https://nsis.sourceforge.io/Download")
                return False
        except FileNotFoundError:
            print("✗ NSIS not found. Please install NSIS to create installer.")
            print("Download from: https://nsis.sourceforge.io/Download")
            return False
            
        try:
            cmd = ["makensis", str(nsis_script)]
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            print("✓ Installer created successfully")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"✗ Installer creation failed: {e}")
            print(f"Error output: {e.stderr}")
            return False
            
    def create_portable_package(self):
        """Create a portable package (zip file)."""
        print("Creating portable package...")
        
        portable_dir = self.installer_dir / f"{self.app_name.replace(' ', '_')}_Portable_v{self.app_version}"
        if portable_dir.exists():
            shutil.rmtree(portable_dir)
        portable_dir.mkdir(exist_ok=True)
        
        # Copy executable files
        exe_dir = self.dist_dir / f"{self.app_name.replace(' ', '_')}"
        if exe_dir.exists():
            shutil.copytree(exe_dir, portable_dir, dirs_exist_ok=True)
            
        # Create README for portable version
        readme_content = f"""# {self.app_name} Portable v{self.app_version}

This is a portable version of {self.app_name}. You can run it from any location without installation.

## Usage
1. Extract this folder to any location
2. Run {self.app_name.replace(' ', '_')}.exe
3. The application will create its database and configuration files in the same directory

## System Requirements
- Windows 10 or later
- 4GB RAM minimum
- 500MB free disk space

## Support
For support, contact: {self.app_author}

## License
This software is provided as-is without warranty.
"""
        
        readme_file = portable_dir / "README.txt"
        with open(readme_file, 'w', encoding='utf-8') as f:
            f.write(readme_content)
            
        # Create zip file
        import zipfile
        zip_file = self.installer_dir / f"{self.app_name.replace(' ', '_')}_Portable_v{self.app_version}.zip"
        
        with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(portable_dir):
                for file in files:
                    file_path = Path(root) / file
                    arc_name = file_path.relative_to(portable_dir)
                    zipf.write(file_path, arc_name)
                    
        print(f"✓ Portable package created: {zip_file}")
        return zip_file
        
    def create_license_file(self):
        """Create a basic license file."""
        license_content = """MIT License

Copyright (c) 2024 Talinda POS Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
        
        license_file = self.project_root / "LICENSE"
        with open(license_file, 'w', encoding='utf-8') as f:
            f.write(license_content)
            
        print(f"✓ Created license file: {license_file}")
        
    def build(self, create_installer=True, create_portable=True):
        """Main build process."""
        print(f"Building {self.app_name} v{self.app_version}")
        print("=" * 50)
        
        # Clean previous builds
        self.clean_build_directories()
        
        # Install dependencies
        if not self.install_dependencies():
            return False
            
        # Create license file
        self.create_license_file()
        
        # Build executable
        if not self.build_executable():
            return False
            
        # Create installer
        if create_installer:
            if not self.create_installer():
                print("Warning: Installer creation failed, but executable was built successfully")
                
        # Create portable package
        if create_portable:
            self.create_portable_package()
            
        print("\n" + "=" * 50)
        print("Build completed successfully!")
        print(f"Executable location: {self.dist_dir}")
        if create_installer:
            print(f"Installer location: {self.installer_dir}")
        if create_portable:
            print(f"Portable package location: {self.installer_dir}")
            
        return True


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Build Talinda POS installer")
    parser.add_argument("--no-installer", action="store_true", help="Skip installer creation")
    parser.add_argument("--no-portable", action="store_true", help="Skip portable package creation")
    
    args = parser.parse_args()
    
    builder = InstallerBuilder()
    success = builder.build(
        create_installer=not args.no_installer,
        create_portable=not args.no_portable
    )
    
    if success:
        print("\n✓ Build completed successfully!")
        sys.exit(0)
    else:
        print("\n✗ Build failed!")
        sys.exit(1)


if __name__ == "__main__":
    main() 